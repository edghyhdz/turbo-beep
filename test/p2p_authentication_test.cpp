#include "tests.h"
#include <chrono>
#include <gtest/gtest.h>
#include <memory>
#include <thread>
#include <stdexcept>


P2PAuthenticationFixture::P2PAuthenticationFixture()
    : _certPath(CERTIFICATES_PATH) {}

P2PAuthenticationFixture::~P2PAuthenticationFixture() {}

std::string const P2PAuthenticationFixture::getPath(std::string &&pathName) {
  return _certPath + pathName; 
}

void P2PAuthenticationFixture::SetUp() {
  // Server arguments
  _ipAddress = new char[10];
  _port = new char[6];
  std::string ipStr = "127.0.0.1";
  std::string portStr = "54705";
  strcpy(_ipAddress, ipStr.c_str());
  strcpy(_port, portStr.c_str());
  std::uint16_t serverPort{54705};
  
  // Peer arguments
  std::string flag{"0"}; 
  std::string keyPairPath = getPath("peer1/mykeypair.pem");
  std::string peerPublicKeyPath = getPath("peer1/peer.pem");
  std::string keyPairPathTwo = getPath("peer2/mykeypair.pem");
  std::string peerPublicKeyPathTwo = getPath("peer2/peer.pem");

  _server = std::make_shared<mediator::Server>(serverPort);
  _peerOne = std::make_shared<p2p::Peer>(_ipAddress, _port, flag, keyPairPath,
                                           peerPublicKeyPath);

  _peerTwo = std::make_shared<p2p::Peer>(_ipAddress, _port, flag, keyPairPathTwo,
                                           peerPublicKeyPathTwo);
}
void P2PAuthenticationFixture::TearDown() {
    _tPeer.join();
  _tServer.detach(); 
  delete[] _ipAddress;
  delete[] _port;
}

// Wrapper function to return 1 upon successful connection of both peers to the
// server
int P2PAuthenticationFixture::peerWrapper() {

  std::mutex m;
  std::condition_variable cv;
  int retval{0};

  std::thread t([&cv, &retval, this]() {
    auto mType = payload::packet_MessageTypes_ADVERTISE; 
    _peerTwo->connectToServer(mType);
    retval = 1;
    cv.notify_one();
  });
  t.detach();
  {
    std::unique_lock<std::mutex> lck(m);
    if (cv.wait_for(lck, std::chrono::seconds(2)) == std::cv_status::timeout) {
      if (!retval) {
        return retval;
      }
    }
  }
  return retval;
}

TEST_F(P2PAuthenticationFixture, SuccessfulDiscconectFromServerAferBothPeersOnline) {
  // Test
  auto mTypePI = payload::packet_MessageTypes_ADVERTISE;
  _tServer = std::thread(&mediator::Server::runServer, _server);
  _tPeer = std::thread(&p2p::Peer::connectToServer, _peerOne,  std::ref(mTypePI));

  // So that we have a different nonce generated by the server (timestamp dependent)
  std::this_thread::sleep_for(std::chrono::milliseconds(1000));
  int retval = peerWrapper();
  ASSERT_EQ(retval, 1);
}
