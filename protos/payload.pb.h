// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: payload.proto

#ifndef PROTOBUF_payload_2eproto__INCLUDED
#define PROTOBUF_payload_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace payload {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_payload_2eproto();
void protobuf_AssignDesc_payload_2eproto();
void protobuf_ShutdownFile_payload_2eproto();

class packet;
class packet_Crypto;
class packet_Payload;
class packet_PeerInfo;

enum packet_MessageTypes {
  packet_MessageTypes_PEER_INFO = 0,
  packet_MessageTypes_ADVERTISE = 1
};
bool packet_MessageTypes_IsValid(int value);
const packet_MessageTypes packet_MessageTypes_MessageTypes_MIN = packet_MessageTypes_PEER_INFO;
const packet_MessageTypes packet_MessageTypes_MessageTypes_MAX = packet_MessageTypes_ADVERTISE;
const int packet_MessageTypes_MessageTypes_ARRAYSIZE = packet_MessageTypes_MessageTypes_MAX + 1;

const ::google::protobuf::EnumDescriptor* packet_MessageTypes_descriptor();
inline const ::std::string& packet_MessageTypes_Name(packet_MessageTypes value) {
  return ::google::protobuf::internal::NameOfEnum(
    packet_MessageTypes_descriptor(), value);
}
inline bool packet_MessageTypes_Parse(
    const ::std::string& name, packet_MessageTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<packet_MessageTypes>(
    packet_MessageTypes_descriptor(), name, value);
}
// ===================================================================

class packet_Payload : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:payload.packet.Payload) */ {
 public:
  packet_Payload();
  virtual ~packet_Payload();

  packet_Payload(const packet_Payload& from);

  inline packet_Payload& operator=(const packet_Payload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const packet_Payload& default_instance();

  void Swap(packet_Payload* other);

  // implements Message ----------------------------------------------

  inline packet_Payload* New() const { return New(NULL); }

  packet_Payload* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const packet_Payload& from);
  void MergeFrom(const packet_Payload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(packet_Payload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .payload.packet.MessageTypes type = 1 [default = PEER_INFO];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::payload::packet_MessageTypes type() const;
  void set_type(::payload::packet_MessageTypes value);

  // optional .payload.packet.PeerInfo peerInfo = 2;
  bool has_peerinfo() const;
  void clear_peerinfo();
  static const int kPeerInfoFieldNumber = 2;
  const ::payload::packet_PeerInfo& peerinfo() const;
  ::payload::packet_PeerInfo* mutable_peerinfo();
  ::payload::packet_PeerInfo* release_peerinfo();
  void set_allocated_peerinfo(::payload::packet_PeerInfo* peerinfo);

  // optional .payload.packet.Crypto crypto = 3;
  bool has_crypto() const;
  void clear_crypto();
  static const int kCryptoFieldNumber = 3;
  const ::payload::packet_Crypto& crypto() const;
  ::payload::packet_Crypto* mutable_crypto();
  ::payload::packet_Crypto* release_crypto();
  void set_allocated_crypto(::payload::packet_Crypto* crypto);

  // @@protoc_insertion_point(class_scope:payload.packet.Payload)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_peerinfo();
  inline void clear_has_peerinfo();
  inline void set_has_crypto();
  inline void clear_has_crypto();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::payload::packet_PeerInfo* peerinfo_;
  ::payload::packet_Crypto* crypto_;
  int type_;
  friend void  protobuf_AddDesc_payload_2eproto();
  friend void protobuf_AssignDesc_payload_2eproto();
  friend void protobuf_ShutdownFile_payload_2eproto();

  void InitAsDefaultInstance();
  static packet_Payload* default_instance_;
};
// -------------------------------------------------------------------

class packet_PeerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:payload.packet.PeerInfo) */ {
 public:
  packet_PeerInfo();
  virtual ~packet_PeerInfo();

  packet_PeerInfo(const packet_PeerInfo& from);

  inline packet_PeerInfo& operator=(const packet_PeerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const packet_PeerInfo& default_instance();

  void Swap(packet_PeerInfo* other);

  // implements Message ----------------------------------------------

  inline packet_PeerInfo* New() const { return New(NULL); }

  packet_PeerInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const packet_PeerInfo& from);
  void MergeFrom(const packet_PeerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(packet_PeerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ipAddress = 1;
  bool has_ipaddress() const;
  void clear_ipaddress();
  static const int kIpAddressFieldNumber = 1;
  const ::std::string& ipaddress() const;
  void set_ipaddress(const ::std::string& value);
  void set_ipaddress(const char* value);
  void set_ipaddress(const char* value, size_t size);
  ::std::string* mutable_ipaddress();
  ::std::string* release_ipaddress();
  void set_allocated_ipaddress(::std::string* ipaddress);

  // required uint32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // required string userName = 3;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:payload.packet.PeerInfo)
 private:
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_username();
  inline void clear_has_username();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ipaddress_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_payload_2eproto();
  friend void protobuf_AssignDesc_payload_2eproto();
  friend void protobuf_ShutdownFile_payload_2eproto();

  void InitAsDefaultInstance();
  static packet_PeerInfo* default_instance_;
};
// -------------------------------------------------------------------

class packet_Crypto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:payload.packet.Crypto) */ {
 public:
  packet_Crypto();
  virtual ~packet_Crypto();

  packet_Crypto(const packet_Crypto& from);

  inline packet_Crypto& operator=(const packet_Crypto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const packet_Crypto& default_instance();

  void Swap(packet_Crypto* other);

  // implements Message ----------------------------------------------

  inline packet_Crypto* New() const { return New(NULL); }

  packet_Crypto* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const packet_Crypto& from);
  void MergeFrom(const packet_Crypto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(packet_Crypto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string clientKey = 1;
  bool has_clientkey() const;
  void clear_clientkey();
  static const int kClientKeyFieldNumber = 1;
  const ::std::string& clientkey() const;
  void set_clientkey(const ::std::string& value);
  void set_clientkey(const char* value);
  void set_clientkey(const char* value, size_t size);
  ::std::string* mutable_clientkey();
  ::std::string* release_clientkey();
  void set_allocated_clientkey(::std::string* clientkey);

  // required bytes hashedKey = 2;
  bool has_hashedkey() const;
  void clear_hashedkey();
  static const int kHashedKeyFieldNumber = 2;
  const ::std::string& hashedkey() const;
  void set_hashedkey(const ::std::string& value);
  void set_hashedkey(const char* value);
  void set_hashedkey(const void* value, size_t size);
  ::std::string* mutable_hashedkey();
  ::std::string* release_hashedkey();
  void set_allocated_hashedkey(::std::string* hashedkey);

  // required bytes encryptedHashedKey = 3;
  bool has_encryptedhashedkey() const;
  void clear_encryptedhashedkey();
  static const int kEncryptedHashedKeyFieldNumber = 3;
  const ::std::string& encryptedhashedkey() const;
  void set_encryptedhashedkey(const ::std::string& value);
  void set_encryptedhashedkey(const char* value);
  void set_encryptedhashedkey(const void* value, size_t size);
  ::std::string* mutable_encryptedhashedkey();
  ::std::string* release_encryptedhashedkey();
  void set_allocated_encryptedhashedkey(::std::string* encryptedhashedkey);

  // required bytes encryptedMsg = 4;
  bool has_encryptedmsg() const;
  void clear_encryptedmsg();
  static const int kEncryptedMsgFieldNumber = 4;
  const ::std::string& encryptedmsg() const;
  void set_encryptedmsg(const ::std::string& value);
  void set_encryptedmsg(const char* value);
  void set_encryptedmsg(const void* value, size_t size);
  ::std::string* mutable_encryptedmsg();
  ::std::string* release_encryptedmsg();
  void set_allocated_encryptedmsg(::std::string* encryptedmsg);

  // @@protoc_insertion_point(class_scope:payload.packet.Crypto)
 private:
  inline void set_has_clientkey();
  inline void clear_has_clientkey();
  inline void set_has_hashedkey();
  inline void clear_has_hashedkey();
  inline void set_has_encryptedhashedkey();
  inline void clear_has_encryptedhashedkey();
  inline void set_has_encryptedmsg();
  inline void clear_has_encryptedmsg();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr clientkey_;
  ::google::protobuf::internal::ArenaStringPtr hashedkey_;
  ::google::protobuf::internal::ArenaStringPtr encryptedhashedkey_;
  ::google::protobuf::internal::ArenaStringPtr encryptedmsg_;
  friend void  protobuf_AddDesc_payload_2eproto();
  friend void protobuf_AssignDesc_payload_2eproto();
  friend void protobuf_ShutdownFile_payload_2eproto();

  void InitAsDefaultInstance();
  static packet_Crypto* default_instance_;
};
// -------------------------------------------------------------------

class packet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:payload.packet) */ {
 public:
  packet();
  virtual ~packet();

  packet(const packet& from);

  inline packet& operator=(const packet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const packet& default_instance();

  void Swap(packet* other);

  // implements Message ----------------------------------------------

  inline packet* New() const { return New(NULL); }

  packet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const packet& from);
  void MergeFrom(const packet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(packet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef packet_Payload Payload;
  typedef packet_PeerInfo PeerInfo;
  typedef packet_Crypto Crypto;

  typedef packet_MessageTypes MessageTypes;
  static const MessageTypes PEER_INFO =
    packet_MessageTypes_PEER_INFO;
  static const MessageTypes ADVERTISE =
    packet_MessageTypes_ADVERTISE;
  static inline bool MessageTypes_IsValid(int value) {
    return packet_MessageTypes_IsValid(value);
  }
  static const MessageTypes MessageTypes_MIN =
    packet_MessageTypes_MessageTypes_MIN;
  static const MessageTypes MessageTypes_MAX =
    packet_MessageTypes_MessageTypes_MAX;
  static const int MessageTypes_ARRAYSIZE =
    packet_MessageTypes_MessageTypes_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageTypes_descriptor() {
    return packet_MessageTypes_descriptor();
  }
  static inline const ::std::string& MessageTypes_Name(MessageTypes value) {
    return packet_MessageTypes_Name(value);
  }
  static inline bool MessageTypes_Parse(const ::std::string& name,
      MessageTypes* value) {
    return packet_MessageTypes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required fixed64 time_stamp = 1;
  bool has_time_stamp() const;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  ::google::protobuf::uint64 time_stamp() const;
  void set_time_stamp(::google::protobuf::uint64 value);

  // required .payload.packet.Payload payload = 2;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 2;
  const ::payload::packet_Payload& payload() const;
  ::payload::packet_Payload* mutable_payload();
  ::payload::packet_Payload* release_payload();
  void set_allocated_payload(::payload::packet_Payload* payload);

  // @@protoc_insertion_point(class_scope:payload.packet)
 private:
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_payload();
  inline void clear_has_payload();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_stamp_;
  ::payload::packet_Payload* payload_;
  friend void  protobuf_AddDesc_payload_2eproto();
  friend void protobuf_AssignDesc_payload_2eproto();
  friend void protobuf_ShutdownFile_payload_2eproto();

  void InitAsDefaultInstance();
  static packet* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// packet_Payload

// required .payload.packet.MessageTypes type = 1 [default = PEER_INFO];
inline bool packet_Payload::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void packet_Payload::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void packet_Payload::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void packet_Payload::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::payload::packet_MessageTypes packet_Payload::type() const {
  // @@protoc_insertion_point(field_get:payload.packet.Payload.type)
  return static_cast< ::payload::packet_MessageTypes >(type_);
}
inline void packet_Payload::set_type(::payload::packet_MessageTypes value) {
  assert(::payload::packet_MessageTypes_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:payload.packet.Payload.type)
}

// optional .payload.packet.PeerInfo peerInfo = 2;
inline bool packet_Payload::has_peerinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void packet_Payload::set_has_peerinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void packet_Payload::clear_has_peerinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void packet_Payload::clear_peerinfo() {
  if (peerinfo_ != NULL) peerinfo_->::payload::packet_PeerInfo::Clear();
  clear_has_peerinfo();
}
inline const ::payload::packet_PeerInfo& packet_Payload::peerinfo() const {
  // @@protoc_insertion_point(field_get:payload.packet.Payload.peerInfo)
  return peerinfo_ != NULL ? *peerinfo_ : *default_instance_->peerinfo_;
}
inline ::payload::packet_PeerInfo* packet_Payload::mutable_peerinfo() {
  set_has_peerinfo();
  if (peerinfo_ == NULL) {
    peerinfo_ = new ::payload::packet_PeerInfo;
  }
  // @@protoc_insertion_point(field_mutable:payload.packet.Payload.peerInfo)
  return peerinfo_;
}
inline ::payload::packet_PeerInfo* packet_Payload::release_peerinfo() {
  // @@protoc_insertion_point(field_release:payload.packet.Payload.peerInfo)
  clear_has_peerinfo();
  ::payload::packet_PeerInfo* temp = peerinfo_;
  peerinfo_ = NULL;
  return temp;
}
inline void packet_Payload::set_allocated_peerinfo(::payload::packet_PeerInfo* peerinfo) {
  delete peerinfo_;
  peerinfo_ = peerinfo;
  if (peerinfo) {
    set_has_peerinfo();
  } else {
    clear_has_peerinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:payload.packet.Payload.peerInfo)
}

// optional .payload.packet.Crypto crypto = 3;
inline bool packet_Payload::has_crypto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void packet_Payload::set_has_crypto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void packet_Payload::clear_has_crypto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void packet_Payload::clear_crypto() {
  if (crypto_ != NULL) crypto_->::payload::packet_Crypto::Clear();
  clear_has_crypto();
}
inline const ::payload::packet_Crypto& packet_Payload::crypto() const {
  // @@protoc_insertion_point(field_get:payload.packet.Payload.crypto)
  return crypto_ != NULL ? *crypto_ : *default_instance_->crypto_;
}
inline ::payload::packet_Crypto* packet_Payload::mutable_crypto() {
  set_has_crypto();
  if (crypto_ == NULL) {
    crypto_ = new ::payload::packet_Crypto;
  }
  // @@protoc_insertion_point(field_mutable:payload.packet.Payload.crypto)
  return crypto_;
}
inline ::payload::packet_Crypto* packet_Payload::release_crypto() {
  // @@protoc_insertion_point(field_release:payload.packet.Payload.crypto)
  clear_has_crypto();
  ::payload::packet_Crypto* temp = crypto_;
  crypto_ = NULL;
  return temp;
}
inline void packet_Payload::set_allocated_crypto(::payload::packet_Crypto* crypto) {
  delete crypto_;
  crypto_ = crypto;
  if (crypto) {
    set_has_crypto();
  } else {
    clear_has_crypto();
  }
  // @@protoc_insertion_point(field_set_allocated:payload.packet.Payload.crypto)
}

// -------------------------------------------------------------------

// packet_PeerInfo

// required string ipAddress = 1;
inline bool packet_PeerInfo::has_ipaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void packet_PeerInfo::set_has_ipaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void packet_PeerInfo::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void packet_PeerInfo::clear_ipaddress() {
  ipaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ipaddress();
}
inline const ::std::string& packet_PeerInfo::ipaddress() const {
  // @@protoc_insertion_point(field_get:payload.packet.PeerInfo.ipAddress)
  return ipaddress_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void packet_PeerInfo::set_ipaddress(const ::std::string& value) {
  set_has_ipaddress();
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payload.packet.PeerInfo.ipAddress)
}
inline void packet_PeerInfo::set_ipaddress(const char* value) {
  set_has_ipaddress();
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payload.packet.PeerInfo.ipAddress)
}
inline void packet_PeerInfo::set_ipaddress(const char* value, size_t size) {
  set_has_ipaddress();
  ipaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payload.packet.PeerInfo.ipAddress)
}
inline ::std::string* packet_PeerInfo::mutable_ipaddress() {
  set_has_ipaddress();
  // @@protoc_insertion_point(field_mutable:payload.packet.PeerInfo.ipAddress)
  return ipaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* packet_PeerInfo::release_ipaddress() {
  // @@protoc_insertion_point(field_release:payload.packet.PeerInfo.ipAddress)
  clear_has_ipaddress();
  return ipaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void packet_PeerInfo::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress != NULL) {
    set_has_ipaddress();
  } else {
    clear_has_ipaddress();
  }
  ipaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ipaddress);
  // @@protoc_insertion_point(field_set_allocated:payload.packet.PeerInfo.ipAddress)
}

// required uint32 port = 2;
inline bool packet_PeerInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void packet_PeerInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void packet_PeerInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void packet_PeerInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 packet_PeerInfo::port() const {
  // @@protoc_insertion_point(field_get:payload.packet.PeerInfo.port)
  return port_;
}
inline void packet_PeerInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:payload.packet.PeerInfo.port)
}

// required string userName = 3;
inline bool packet_PeerInfo::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void packet_PeerInfo::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void packet_PeerInfo::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void packet_PeerInfo::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& packet_PeerInfo::username() const {
  // @@protoc_insertion_point(field_get:payload.packet.PeerInfo.userName)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void packet_PeerInfo::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payload.packet.PeerInfo.userName)
}
inline void packet_PeerInfo::set_username(const char* value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payload.packet.PeerInfo.userName)
}
inline void packet_PeerInfo::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payload.packet.PeerInfo.userName)
}
inline ::std::string* packet_PeerInfo::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:payload.packet.PeerInfo.userName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* packet_PeerInfo::release_username() {
  // @@protoc_insertion_point(field_release:payload.packet.PeerInfo.userName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void packet_PeerInfo::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:payload.packet.PeerInfo.userName)
}

// -------------------------------------------------------------------

// packet_Crypto

// required string clientKey = 1;
inline bool packet_Crypto::has_clientkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void packet_Crypto::set_has_clientkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void packet_Crypto::clear_has_clientkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void packet_Crypto::clear_clientkey() {
  clientkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientkey();
}
inline const ::std::string& packet_Crypto::clientkey() const {
  // @@protoc_insertion_point(field_get:payload.packet.Crypto.clientKey)
  return clientkey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void packet_Crypto::set_clientkey(const ::std::string& value) {
  set_has_clientkey();
  clientkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payload.packet.Crypto.clientKey)
}
inline void packet_Crypto::set_clientkey(const char* value) {
  set_has_clientkey();
  clientkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payload.packet.Crypto.clientKey)
}
inline void packet_Crypto::set_clientkey(const char* value, size_t size) {
  set_has_clientkey();
  clientkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payload.packet.Crypto.clientKey)
}
inline ::std::string* packet_Crypto::mutable_clientkey() {
  set_has_clientkey();
  // @@protoc_insertion_point(field_mutable:payload.packet.Crypto.clientKey)
  return clientkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* packet_Crypto::release_clientkey() {
  // @@protoc_insertion_point(field_release:payload.packet.Crypto.clientKey)
  clear_has_clientkey();
  return clientkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void packet_Crypto::set_allocated_clientkey(::std::string* clientkey) {
  if (clientkey != NULL) {
    set_has_clientkey();
  } else {
    clear_has_clientkey();
  }
  clientkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientkey);
  // @@protoc_insertion_point(field_set_allocated:payload.packet.Crypto.clientKey)
}

// required bytes hashedKey = 2;
inline bool packet_Crypto::has_hashedkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void packet_Crypto::set_has_hashedkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void packet_Crypto::clear_has_hashedkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void packet_Crypto::clear_hashedkey() {
  hashedkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hashedkey();
}
inline const ::std::string& packet_Crypto::hashedkey() const {
  // @@protoc_insertion_point(field_get:payload.packet.Crypto.hashedKey)
  return hashedkey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void packet_Crypto::set_hashedkey(const ::std::string& value) {
  set_has_hashedkey();
  hashedkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payload.packet.Crypto.hashedKey)
}
inline void packet_Crypto::set_hashedkey(const char* value) {
  set_has_hashedkey();
  hashedkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payload.packet.Crypto.hashedKey)
}
inline void packet_Crypto::set_hashedkey(const void* value, size_t size) {
  set_has_hashedkey();
  hashedkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payload.packet.Crypto.hashedKey)
}
inline ::std::string* packet_Crypto::mutable_hashedkey() {
  set_has_hashedkey();
  // @@protoc_insertion_point(field_mutable:payload.packet.Crypto.hashedKey)
  return hashedkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* packet_Crypto::release_hashedkey() {
  // @@protoc_insertion_point(field_release:payload.packet.Crypto.hashedKey)
  clear_has_hashedkey();
  return hashedkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void packet_Crypto::set_allocated_hashedkey(::std::string* hashedkey) {
  if (hashedkey != NULL) {
    set_has_hashedkey();
  } else {
    clear_has_hashedkey();
  }
  hashedkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashedkey);
  // @@protoc_insertion_point(field_set_allocated:payload.packet.Crypto.hashedKey)
}

// required bytes encryptedHashedKey = 3;
inline bool packet_Crypto::has_encryptedhashedkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void packet_Crypto::set_has_encryptedhashedkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void packet_Crypto::clear_has_encryptedhashedkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void packet_Crypto::clear_encryptedhashedkey() {
  encryptedhashedkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_encryptedhashedkey();
}
inline const ::std::string& packet_Crypto::encryptedhashedkey() const {
  // @@protoc_insertion_point(field_get:payload.packet.Crypto.encryptedHashedKey)
  return encryptedhashedkey_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void packet_Crypto::set_encryptedhashedkey(const ::std::string& value) {
  set_has_encryptedhashedkey();
  encryptedhashedkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payload.packet.Crypto.encryptedHashedKey)
}
inline void packet_Crypto::set_encryptedhashedkey(const char* value) {
  set_has_encryptedhashedkey();
  encryptedhashedkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payload.packet.Crypto.encryptedHashedKey)
}
inline void packet_Crypto::set_encryptedhashedkey(const void* value, size_t size) {
  set_has_encryptedhashedkey();
  encryptedhashedkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payload.packet.Crypto.encryptedHashedKey)
}
inline ::std::string* packet_Crypto::mutable_encryptedhashedkey() {
  set_has_encryptedhashedkey();
  // @@protoc_insertion_point(field_mutable:payload.packet.Crypto.encryptedHashedKey)
  return encryptedhashedkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* packet_Crypto::release_encryptedhashedkey() {
  // @@protoc_insertion_point(field_release:payload.packet.Crypto.encryptedHashedKey)
  clear_has_encryptedhashedkey();
  return encryptedhashedkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void packet_Crypto::set_allocated_encryptedhashedkey(::std::string* encryptedhashedkey) {
  if (encryptedhashedkey != NULL) {
    set_has_encryptedhashedkey();
  } else {
    clear_has_encryptedhashedkey();
  }
  encryptedhashedkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encryptedhashedkey);
  // @@protoc_insertion_point(field_set_allocated:payload.packet.Crypto.encryptedHashedKey)
}

// required bytes encryptedMsg = 4;
inline bool packet_Crypto::has_encryptedmsg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void packet_Crypto::set_has_encryptedmsg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void packet_Crypto::clear_has_encryptedmsg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void packet_Crypto::clear_encryptedmsg() {
  encryptedmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_encryptedmsg();
}
inline const ::std::string& packet_Crypto::encryptedmsg() const {
  // @@protoc_insertion_point(field_get:payload.packet.Crypto.encryptedMsg)
  return encryptedmsg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void packet_Crypto::set_encryptedmsg(const ::std::string& value) {
  set_has_encryptedmsg();
  encryptedmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:payload.packet.Crypto.encryptedMsg)
}
inline void packet_Crypto::set_encryptedmsg(const char* value) {
  set_has_encryptedmsg();
  encryptedmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:payload.packet.Crypto.encryptedMsg)
}
inline void packet_Crypto::set_encryptedmsg(const void* value, size_t size) {
  set_has_encryptedmsg();
  encryptedmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:payload.packet.Crypto.encryptedMsg)
}
inline ::std::string* packet_Crypto::mutable_encryptedmsg() {
  set_has_encryptedmsg();
  // @@protoc_insertion_point(field_mutable:payload.packet.Crypto.encryptedMsg)
  return encryptedmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* packet_Crypto::release_encryptedmsg() {
  // @@protoc_insertion_point(field_release:payload.packet.Crypto.encryptedMsg)
  clear_has_encryptedmsg();
  return encryptedmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void packet_Crypto::set_allocated_encryptedmsg(::std::string* encryptedmsg) {
  if (encryptedmsg != NULL) {
    set_has_encryptedmsg();
  } else {
    clear_has_encryptedmsg();
  }
  encryptedmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encryptedmsg);
  // @@protoc_insertion_point(field_set_allocated:payload.packet.Crypto.encryptedMsg)
}

// -------------------------------------------------------------------

// packet

// required fixed64 time_stamp = 1;
inline bool packet::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void packet::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void packet::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void packet::clear_time_stamp() {
  time_stamp_ = GOOGLE_ULONGLONG(0);
  clear_has_time_stamp();
}
inline ::google::protobuf::uint64 packet::time_stamp() const {
  // @@protoc_insertion_point(field_get:payload.packet.time_stamp)
  return time_stamp_;
}
inline void packet::set_time_stamp(::google::protobuf::uint64 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:payload.packet.time_stamp)
}

// required .payload.packet.Payload payload = 2;
inline bool packet::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void packet::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void packet::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void packet::clear_payload() {
  if (payload_ != NULL) payload_->::payload::packet_Payload::Clear();
  clear_has_payload();
}
inline const ::payload::packet_Payload& packet::payload() const {
  // @@protoc_insertion_point(field_get:payload.packet.payload)
  return payload_ != NULL ? *payload_ : *default_instance_->payload_;
}
inline ::payload::packet_Payload* packet::mutable_payload() {
  set_has_payload();
  if (payload_ == NULL) {
    payload_ = new ::payload::packet_Payload;
  }
  // @@protoc_insertion_point(field_mutable:payload.packet.payload)
  return payload_;
}
inline ::payload::packet_Payload* packet::release_payload() {
  // @@protoc_insertion_point(field_release:payload.packet.payload)
  clear_has_payload();
  ::payload::packet_Payload* temp = payload_;
  payload_ = NULL;
  return temp;
}
inline void packet::set_allocated_payload(::payload::packet_Payload* payload) {
  delete payload_;
  payload_ = payload;
  if (payload) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  // @@protoc_insertion_point(field_set_allocated:payload.packet.payload)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace payload

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::payload::packet_MessageTypes> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::payload::packet_MessageTypes>() {
  return ::payload::packet_MessageTypes_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_payload_2eproto__INCLUDED
